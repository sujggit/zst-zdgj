// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `MediaNodeMgrPrx.java'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package vmxICE;

/**
 * [MediaNode]是mmap6框架中的多媒体节点基类，提供了多媒体节点的通用接口。
 **/
public interface MediaNodeMgrPrx extends ObjectMgrPrx
{
    /**
     * 节点的接收数据函数，
     * 
     * @param nodeIndex 数据到达的节点的索引。
     * @param padIndex 数据到达的节点的pad的索引，顺序需要和nodeIndex保持一致。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @return 返回值为0代表成功，否则为失败的错误码.
     * 
     **/
    public void recvMedia(int nodeIndex, int padIndex, byte[] seq);

    /**
     * 节点的接收数据函数，
     * 
     * @param nodeIndex 数据到达的节点的索引。
     * @param padIndex 数据到达的节点的pad的索引，顺序需要和nodeIndex保持一致。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @param __ctx The Context map to send with the invocation.
     * @return 返回值为0代表成功，否则为失败的错误码.
     * 
     **/
    public void recvMedia(int nodeIndex, int padIndex, byte[] seq, java.util.Map<String, String> __ctx);

    /**
     * 节点的接收数据函数，
     * 
     * @param nodeIndex 数据到达的节点的索引。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @return The asynchronous result object.
     **/
    public Ice.AsyncResult begin_recvMedia(int nodeIndex, int padIndex, byte[] seq);

    /**
     * 节点的接收数据函数，
     * 
     * @param nodeIndex 数据到达的节点的索引。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @param __ctx The Context map to send with the invocation.
     * @return The asynchronous result object.
     **/
    public Ice.AsyncResult begin_recvMedia(int nodeIndex, int padIndex, byte[] seq, java.util.Map<String, String> __ctx);

    /**
     * 节点的接收数据函数，
     * 
     * @param nodeIndex 数据到达的节点的索引。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @param __cb The asynchronous callback object.
     * @return The asynchronous result object.
     **/
    public Ice.AsyncResult begin_recvMedia(int nodeIndex, int padIndex, byte[] seq, Ice.Callback __cb);

    /**
     * 节点的接收数据函数，
     * 
     * @param nodeIndex 数据到达的节点的索引。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @param __ctx The Context map to send with the invocation.
     * @param __cb The asynchronous callback object.
     * @return The asynchronous result object.
     **/
    public Ice.AsyncResult begin_recvMedia(int nodeIndex, int padIndex, byte[] seq, java.util.Map<String, String> __ctx, Ice.Callback __cb);

    /**
     * 节点的接收数据函数，
     * 
     * @param nodeIndex 数据到达的节点的索引。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @param __cb The asynchronous callback object.
     * @return The asynchronous result object.
     **/
    public Ice.AsyncResult begin_recvMedia(int nodeIndex, int padIndex, byte[] seq, Callback_MediaNodeMgr_recvMedia __cb);

    /**
     * 节点的接收数据函数，
     * 
     * @param nodeIndex 数据到达的节点的索引。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @param __ctx The Context map to send with the invocation.
     * @param __cb The asynchronous callback object.
     * @return The asynchronous result object.
     **/
    public Ice.AsyncResult begin_recvMedia(int nodeIndex, int padIndex, byte[] seq, java.util.Map<String, String> __ctx, Callback_MediaNodeMgr_recvMedia __cb);

    /**
     * 节点的接收数据函数，
     * 
     * @param __result The asynchronous result object.
     * @return 返回值为0代表成功，否则为失败的错误码.
     * 
     **/
    public void end_recvMedia(Ice.AsyncResult __result);

    /**
     * 节点的接收数据函数，和recvMedia的区别在于可以接受多个池中的对象的数据，
     * 
     * @param nodeIndexList 数据到达的节点的索引列表。
     * @param padIndexList 数据到达的节点的pad的索引列表，顺序需要和nodeIndex保持一致。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @return 返回值为0代表成功，否则为失败的错误码.
     * 
     **/
    public void recvMediaEx(int[] nodeIndexList, int[] padIndexList, byte[] seq);

    /**
     * 节点的接收数据函数，和recvMedia的区别在于可以接受多个池中的对象的数据，
     * 
     * @param nodeIndexList 数据到达的节点的索引列表。
     * @param padIndexList 数据到达的节点的pad的索引列表，顺序需要和nodeIndex保持一致。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @param __ctx The Context map to send with the invocation.
     * @return 返回值为0代表成功，否则为失败的错误码.
     * 
     **/
    public void recvMediaEx(int[] nodeIndexList, int[] padIndexList, byte[] seq, java.util.Map<String, String> __ctx);

    /**
     * 节点的接收数据函数，和recvMedia的区别在于可以接受多个池中的对象的数据，
     * 
     * @param nodeIndexList 数据到达的节点的索引列表。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @return The asynchronous result object.
     **/
    public Ice.AsyncResult begin_recvMediaEx(int[] nodeIndexList, int[] padIndexList, byte[] seq);

    /**
     * 节点的接收数据函数，和recvMedia的区别在于可以接受多个池中的对象的数据，
     * 
     * @param nodeIndexList 数据到达的节点的索引列表。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @param __ctx The Context map to send with the invocation.
     * @return The asynchronous result object.
     **/
    public Ice.AsyncResult begin_recvMediaEx(int[] nodeIndexList, int[] padIndexList, byte[] seq, java.util.Map<String, String> __ctx);

    /**
     * 节点的接收数据函数，和recvMedia的区别在于可以接受多个池中的对象的数据，
     * 
     * @param nodeIndexList 数据到达的节点的索引列表。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @param __cb The asynchronous callback object.
     * @return The asynchronous result object.
     **/
    public Ice.AsyncResult begin_recvMediaEx(int[] nodeIndexList, int[] padIndexList, byte[] seq, Ice.Callback __cb);

    /**
     * 节点的接收数据函数，和recvMedia的区别在于可以接受多个池中的对象的数据，
     * 
     * @param nodeIndexList 数据到达的节点的索引列表。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @param __ctx The Context map to send with the invocation.
     * @param __cb The asynchronous callback object.
     * @return The asynchronous result object.
     **/
    public Ice.AsyncResult begin_recvMediaEx(int[] nodeIndexList, int[] padIndexList, byte[] seq, java.util.Map<String, String> __ctx, Ice.Callback __cb);

    /**
     * 节点的接收数据函数，和recvMedia的区别在于可以接受多个池中的对象的数据，
     * 
     * @param nodeIndexList 数据到达的节点的索引列表。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @param __cb The asynchronous callback object.
     * @return The asynchronous result object.
     **/
    public Ice.AsyncResult begin_recvMediaEx(int[] nodeIndexList, int[] padIndexList, byte[] seq, Callback_MediaNodeMgr_recvMediaEx __cb);

    /**
     * 节点的接收数据函数，和recvMedia的区别在于可以接受多个池中的对象的数据，
     * 
     * @param nodeIndexList 数据到达的节点的索引列表。
     * @param seq 传递的数据包，数据包的格式通过vmx_media::IMediaFrameBuffer的toVector()获取，同样，这种数据包可以通过vmx_media::IMediaFrameBuffer.fromVector()来解析.
     * 
     * @param __ctx The Context map to send with the invocation.
     * @param __cb The asynchronous callback object.
     * @return The asynchronous result object.
     **/
    public Ice.AsyncResult begin_recvMediaEx(int[] nodeIndexList, int[] padIndexList, byte[] seq, java.util.Map<String, String> __ctx, Callback_MediaNodeMgr_recvMediaEx __cb);

    /**
     * 节点的接收数据函数，和recvMedia的区别在于可以接受多个池中的对象的数据，
     * 
     * @param __result The asynchronous result object.
     * @return 返回值为0代表成功，否则为失败的错误码.
     * 
     **/
    public void end_recvMediaEx(Ice.AsyncResult __result);
}
